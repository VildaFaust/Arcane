
Предоставление возможности расширения API;
Предоставление возможности масштабирования имеющегося ядра;
Предоставление возможности легкого добавления своих сторонних механик;
Предоставление высокоуровневого и удобочитаемого кода приложения;
Предоставление готовой к расширению системы связи клиента с сервером посредством добавления своих сторонних Service`ов и Hadler`ов;
Репликация данных с базы данных на сервер;
Удобство работы с базой данных;
Соблюдение основных паттернов ООП
Следование правилам SOLID


#Структура

ServerCore - главенствующий модуль, в котором содержатся все основные механики сервера (репликация, сериализация и десериализация).
Utilities - дополнительный модуль, содержащий все необходимые интерфейсы и классы, вспомогательные для классов ServerCore.
Handlers - модуль, содержащий все сущности Handlers
Services - модуль, содержащий все сущности Services
Messages - модуль, содержащий все сущности Messages

# DataContext
![image](https://user-images.githubusercontent.com/27083223/122810162-b3b95000-d2d7-11eb-882a-68faa4891e15.png)

Основная сущность сервера и корень всей архитектуры - это сущность контекста (рисунок 1), которая хранит все ранее созданные модельные данные. Благодаря такому решению, обратиться к нужным данным и, при необходимости, переписать их можно из любого места в коде.
Приходим к выводу, что это решение универсально и подходит под разные спектры задач, будь то работа с базами данных или иными сервисами. Более широкий функционал даёт свободу действиям разработчикам, что бесспорно лучше для использования “обрывков” кода, собранных из специализированных источников. 


#Services

Для того, чтобы понять, как работают запросы, сначала следует разобрать систему сервисов: все сервисы существуют в определенных коллекциях, что упрощает их понимание и разделение на логические группы. Сам сервис представляет собой сущность, которая используется для решения конкретной  задачи. Можем определить простую связь: один сервис - одна задача. Во-первых, это грамотное следование принципам SOLID. Во-вторых, сущности становятся емкими. В-третьих, при удалении того или иного сервиса не будет задеваться инфраструктура сервера. 

![image](https://user-images.githubusercontent.com/27083223/122810180-b74cd700-d2d7-11eb-9a29-21e87b16677d.png)

Разберем принцип сервиса в полном его понимании: допустим, понадобилось внедрить свою кастомную коллекцию сервисов для новой механики, к примеру, создание комнат, куда могут подключиться N клиентов. Начиная продумывать структуру, мы понимаем, что необходимо выделить отдельную группу сервисов, включающую в себя создание, подключение, обновление состояния комнаты и отключение от нее. Проанализировав рисунок 2, приходим к выводу: первым шагом к созданию кастомных сервисов будет их регистрация в фабрике WorldServicesFactory. Это позволит классу 


#Handlers

![image](https://user-images.githubusercontent.com/27083223/122810107-a0a68000-d2d7-11eb-9e17-70d599a515fe.png)
Рисунок 3.

Обработчик запросов приложения (Handler) пользователя (рисунок 3) содержит логику сбора и компоновки данных, отправленных клиентом. Под каждый тип запроса, а, следовательно, уникальную механику и данные, создается отдельный Handler. Декомпозиция на множество сущностей дает простое восприятие взаимодействия данных, к примеру, конкретный JoinWorldHandler соответствует JoinWorldServies. Такая прямая зависимость позволяет воспринимать каждую механику в отдельности, и, одновременно с этим, рамках глобального проекта.


#Репликация базы данных
![image](https://user-images.githubusercontent.com/27083223/122810148-af8d3280-d2d7-11eb-85e0-93c116b09bce.png)


Имеется глобальный конфигурационный файл типа .json, в котором удобно производить все необходимые настройки для работы с базой данных и сервером. Удобство выбранного формата файла заключается в приятной и интуитивно понятной архитектуре, а так же и его небольшой размер.  Конфигурационный файл позволяет осуществить вариативность подключения к разным типам баз данных. Первым классом, взаимодействующим с конфигом, (рисунок 4) является DatabaseConnectionStep. Метод Execute() считывает данные из файла и создает новый экземпляр класса MongoDataBaseConnection, отправляя в него нужные параметры подключения. Далее вызывается метод OpenConnect(), в котором происходит попытка открытия связи с базой данных.
Реализована базовая репликация основных сущностей для взаимодействия с сервисами. Настройки репликации вынесены в конфигурационный файл, что позволяет сразу связать сущности на сервере с сущностями в базе данных, а также настроить параметры, в том числе и временные, для сериализации и десериализации этих сущностей.
